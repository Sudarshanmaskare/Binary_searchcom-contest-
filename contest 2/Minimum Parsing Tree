You are given a list of unique and sorted integers nums representing breakpoints in a string and want to create a tree out of these rules:

Nodes have a value (a, b) where a and b are breakpoints. This means the node spans from indices [a, b) in the string.
The root node spans over the all breakpoints (i.e. the whole string).
The spans of a node's left and right child are ordered, contiguous, and comprise the parent node's span.
Leaf nodes' index of a in breakpoints is 1 before the index of b in breakpoints.
The cost of a tree is defined as the sum of b - a for every node in the tree. Return the minimum cost of a feasible tree.\


int cal(vector<int> &bre,vector<vector<int>> &dp,int i,int j){
    if(i>=j) return 0;

    if(j-1==i) return bre[j]-bre[i];
    if(dp[i][j]!=-1) return dp[i][j];
    int mini=INT_MAX;

    for(int k=i+1;k<j;k++){
        mini=min(mini,cal(bre,dp,i,k)+cal(bre,dp,k,j));
    }
    return dp[i][j]=mini+bre[j]-bre[i];
}

int solve(vector<int>& bre) {
 int n=bre.size();

 vector<vector<int>> dp(n,vector<int>(n,-1));

 return cal(bre,dp,0,n-1);
}
